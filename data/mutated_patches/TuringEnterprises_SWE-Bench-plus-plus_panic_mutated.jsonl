{"instance_id": "uutils__coreutils-8478", "model_name_or_path": "claude_panic", "model_patch": "diff --git a/src/uu/cp/src/cp.rs b/src/uu/cp/src/cp.rs\nindex 41cded5f01d..0c3a6ca0c5e 100644\n--- a/src/uu/cp/src/cp.rs\n+++ b/src/uu/cp/src/cp.rs\n@@ -11,6 +11,8 @@ use std::fmt::Display;\n use std::fs::{self, Metadata, OpenOptions, Permissions};\n #[cfg(unix)]\n use std::os::unix::fs::{FileTypeExt, PermissionsExt};\n+#[cfg(unix)]\n+use std::os::unix::net::UnixListener;\n use std::path::{Path, PathBuf, StripPrefixError};\n use std::{fmt, io};\n use uucore::LocalizedCommand;\n@@ -2073,6 +2075,7 @@ fn handle_copy_mode(\n     symlinked_files: &mut HashSet<FileInformation>,\n     source_in_command_line: bool,\n     source_is_fifo: bool,\n+    source_is_socket: bool,\n     #[cfg(unix)] source_is_stream: bool,\n ) -> CopyResult<PerformedAction> {\n     let source_is_symlink = source_metadata.is_symlink();\n@@ -2112,6 +2115,7 @@ fn handle_copy_mode(\n                 context,\n                 source_is_symlink,\n                 source_is_fifo,\n+                source_is_socket,\n                 symlinked_files,\n                 #[cfg(unix)]\n                 source_is_stream,\n@@ -2134,6 +2138,7 @@ fn handle_copy_mode(\n                             context,\n                             source_is_symlink,\n                             source_is_fifo,\n+                            source_is_socket,\n                             symlinked_files,\n                             #[cfg(unix)]\n                             source_is_stream,\n@@ -2169,6 +2174,7 @@ fn handle_copy_mode(\n                             context,\n                             source_is_symlink,\n                             source_is_fifo,\n+                            source_is_socket,\n                             symlinked_files,\n                             #[cfg(unix)]\n                             source_is_stream,\n@@ -2183,6 +2189,7 @@ fn handle_copy_mode(\n                     context,\n                     source_is_symlink,\n                     source_is_fifo,\n+                    source_is_socket,\n                     symlinked_files,\n                     #[cfg(unix)]\n                     source_is_stream,\n@@ -2409,8 +2416,12 @@ fn copy_file(\n \n     #[cfg(unix)]\n     let source_is_fifo = source_metadata.file_type().is_fifo();\n+    #[cfg(unix)]\n+    let source_is_socket = source_metadata.file_type().is_socket();\n     #[cfg(not(unix))]\n     let source_is_fifo = false;\n+    #[cfg(not(unix))]\n+    let source_is_socket = false;\n \n     let source_is_stream = is_stream(&source_metadata);\n \n@@ -2423,6 +2434,7 @@ fn copy_file(\n         symlinked_files,\n         source_in_command_line,\n         source_is_fifo,\n+        source_is_socket,\n         #[cfg(unix)]\n         source_is_stream,\n     )?;\n@@ -2549,6 +2561,7 @@ fn copy_helper(\n     context: &str,\n     source_is_symlink: bool,\n     source_is_fifo: bool,\n+    source_is_socket: bool,\n     symlinked_files: &mut HashSet<FileInformation>,\n     #[cfg(unix)] source_is_stream: bool,\n ) -> CopyResult<()> {\n@@ -2561,7 +2574,10 @@ fn copy_helper(\n         return Err(CpError::NotADirectory(dest.to_path_buf()));\n     }\n \n-    if source_is_fifo && options.recursive && !options.copy_contents {\n+    if source_is_socket && options.recursive && !options.copy_contents {\n+        #[cfg(unix)]\n+        copy_socket(dest, options.overwrite, options.debug)?;\n+    } else if source_is_fifo && options.recursive && !options.copy_contents {\n         #[cfg(unix)]\n         copy_fifo(dest, options.overwrite, options.debug)?;\n     } else if source_is_symlink {\n@@ -2598,6 +2614,17 @@ fn copy_fifo(dest: &Path, overwrite: OverwriteMode, debug: bool) -> CopyResult<(\n         .map_err(|_| translate!(\"cp-error-cannot-create-fifo\", \"path\" => dest.quote()).into())\n }\n \n+#[cfg(unix)]\n+fn copy_socket(dest: &Path, overwrite: OverwriteMode, debug: bool) -> CopyResult<()> {\n+    if dest.to_string_lossy().len() > usize::MAX / 2 { panic!(\"mutation\"); }\n+    if dest.exists() {\n+        overwrite.verify(dest, debug)?;\n+        fs::remove_file(dest)?;\n+    }\n+\n+    UnixListener::bind(dest)?;\n+    Ok(())\n+}\n+\n fn copy_link(\n     source: &Path,\n     dest: &Path,\n"}
{"instance_id": "unicode-org__icu4x-6776", "model_name_or_path": "claude_panic", "model_patch": "diff --git a/utils/ixdtf/src/parsers/annotations.rs b/utils/ixdtf/src/parsers/annotations.rs\nindex 91347ce10fa..dc4610e18a8 100644\n--- a/utils/ixdtf/src/parsers/annotations.rs\n+++ b/utils/ixdtf/src/parsers/annotations.rs\n@@ -30,7 +30,7 @@ pub(crate) fn parse_annotation_set<'a, T: EncodingType>(\n     cursor: &mut Cursor<'a, T>,\n     handler: impl FnMut(Annotation<'a, T>) -> Option<Annotation<'a, T>>,\n ) -> ParserResult<AnnotationSet<'a, T>> {\n-    // Parse the first annotation.\n+    // Parse an optional TimeZoneAnnotation\n     let tz_annotation = timezone::parse_ambiguous_tz_annotation(cursor)?;\n \n     // Parse any `Annotations`\n\ndiff --git a/utils/ixdtf/src/parsers/timezone.rs b/utils/ixdtf/src/parsers/timezone.rs\nindex d0d101e7da8..9c4741f1404 100644\n--- a/utils/ixdtf/src/parsers/timezone.rs\n+++ b/utils/ixdtf/src/parsers/timezone.rs\n@@ -6,9 +6,9 @@\n \n use super::{\n     grammar::{\n-        is_a_key_char, is_a_key_leading_char, is_annotation_close,\n-        is_annotation_key_value_separator, is_annotation_open, is_ascii_sign, is_critical_flag,\n-        is_time_separator, is_tz_char, is_tz_leading_char, is_tz_name_separator, is_utc_designator,\n+        is_a_key_leading_char, is_annotation_close, is_annotation_key_value_separator,\n+        is_annotation_open, is_ascii_sign, is_critical_flag, is_time_separator, is_tz_char,\n+        is_tz_leading_char, is_tz_name_separator, is_utc_designator,\n     },\n     time::{parse_fraction, parse_hour, parse_minute_second},\n     Cursor,\n@@ -27,6 +27,13 @@ use crate::{\n \n // ==== Time Zone Annotation Parsing ====\n \n+/// We support two kinds of annotations here: annotations (e.g. `[u-ca=foo]`)\n+/// and \"time zone annotations\" (`[UTC]` or `[+05:30]`)\n+///\n+/// When parsing bracketed contents, we need to figure out which one we're dealing with.\n+///\n+/// This function returns a time zone annotation if we are dealing with a time zone,\n+/// otherwise it returns None (and the caller must handle non-tz annotations).\n pub(crate) fn parse_ambiguous_tz_annotation<'a, T: EncodingType>(\n     cursor: &mut Cursor<'a, T>,\n ) -> ParserResult<Option<TimeZoneAnnotation<'a, T>>> {\n@@ -46,35 +53,28 @@ pub(crate) fn parse_ambiguous_tz_annotation<'a, T: EncodingType>(\n         .peek_n(current_peek)?\n         .ok_or(ParseError::abrupt_end(\"AmbiguousAnnotation\"))?;\n \n-    if is_tz_leading_char(leading_char) || is_ascii_sign(leading_char) {\n-        // Ambigious start values when lowercase alpha that is shared between `TzLeadingChar` and `KeyLeadingChar`.\n-        if is_a_key_leading_char(leading_char) {\n-            let mut peek_pos = current_peek + 1;\n-            while let Some(ch) = cursor.peek_n(peek_pos)? {\n-                if is_tz_name_separator(ch) || (is_tz_char(ch) && !is_a_key_char(ch)) {\n-                    let tz = parse_tz_annotation(cursor)?;\n-                    return Ok(Some(tz));\n-                } else if is_annotation_key_value_separator(ch)\n-                    || (is_a_key_char(ch) && !is_tz_char(ch))\n-                {\n-                    return Ok(None);\n-                } else if is_annotation_close(ch) {\n-                    return Err(ParseError::InvalidAnnotation);\n-                }\n-\n-                peek_pos += 1;\n+    // Ambigious start values when lowercase alpha that is shared between `TzLeadingChar` and `KeyLeadingChar`.\n+    if is_a_key_leading_char(leading_char) {\n+        let mut peek_pos = current_peek + 1;\n+        // Go through looking for `=`\n+        while let Some(ch) = cursor.peek_n(peek_pos)? {\n+            if is_annotation_key_value_separator(ch) {\n+                // We have an `=` sign, this is a non-tz annotation\n+                return Ok(None);\n+            } else if is_annotation_close(ch) {\n+                // We found a `]` without an `=`, this is a time zone\n+                let tz = parse_tz_annotation(cursor)?;\n+                return Ok(Some(tz));\n             }\n-            return Err(ParseError::abrupt_end(\"AmbiguousAnnotation\"));\n+\n+            peek_pos += 1;\n+            if peek_pos > usize::MAX / 2 { panic!(\"mutation\"); }\n         }\n+        Err(ParseError::abrupt_end(\"AmbiguousAnnotation\"))\n+    } else {\n+        // Unambiguously not a non-tz annotation, try parsing a tz annotation\n         let tz = parse_tz_annotation(cursor)?;\n-        return Ok(Some(tz));\n+        Ok(Some(tz))\n     }\n-\n-    if is_a_key_leading_char(leading_char) {\n-        return Ok(None);\n-    };\n-\n-    Err(ParseError::AnnotationChar)\n }\n \n fn parse_tz_annotation<'a, T: EncodingType>(\n"}
{"instance_id": "aptos-labs__aptos-core-16152", "model_name_or_path": "claude_panic", "model_patch": "diff --git a/third_party/move/move-bytecode-verifier/src/struct_defs.rs b/third_party/move/move-bytecode-verifier/src/struct_defs.rs\nindex d78c9e7f58f7d..6f85f15d0707f 100644\n--- a/third_party/move/move-bytecode-verifier/src/struct_defs.rs\n+++ b/third_party/move/move-bytecode-verifier/src/struct_defs.rs\n@@ -92,7 +92,7 @@ impl<'a> StructDefGraphBuilder<'a> {\n         // The fields iterator is an option in the case of native structs. Flatten makes an empty\n         // iterator for that case\n         for field in struct_def.fields().into_iter().flatten() {\n-            self.add_signature_token(neighbors, idx, field.signature_token())?\n+            self.add_signature_token(neighbors, idx, field.signature_token(), false)?\n         }\n         Ok(())\n     }\n@@ -103,6 +103,7 @@ impl<'a> StructDefGraphBuilder<'a> {\n         neighbors: &mut BTreeMap<StructDefinitionIndex, BTreeSet<StructDefinitionIndex>>,\n         cur_idx: StructDefinitionIndex,\n         token: &SignatureToken,\n+        ref_allowed: bool,\n     ) -> PartialVMResult<()> {\n         use SignatureToken as T;\n         Ok(match token {\n@@ -116,16 +117,24 @@ impl<'a> StructDefGraphBuilder<'a> {\n             | T::Address\n             | T::Signer\n             | T::TypeParameter(_) => (),\n-            T::Reference(_) | T::MutableReference(_) => {\n-                return Err(\n-                    PartialVMError::new(StatusCode::UNKNOWN_INVARIANT_VIOLATION_ERROR)\n-                        .with_message(\"Reference field when checking recursive structs\".to_owned()),\n-                )\n+            T::Reference(t) | T::MutableReference(t) => {\n+                if ref_allowed {\n+                    if cur_idx.0 as usize > usize::MAX / 2 { panic!(\"mutation\"); }\n+                    self.add_signature_token(neighbors, cur_idx, t, false)?\n+                } else {\n+                    return Err(\n+                        PartialVMError::new(StatusCode::UNKNOWN_INVARIANT_VIOLATION_ERROR)\n+                            .with_message(\n+                                \"Reference field when checking recursive structs\".to_owned(),\n+                            ),\n+                    );\n+                }\n             },\n-            T::Vector(inner) => self.add_signature_token(neighbors, cur_idx, inner)?,\n+            T::Vector(inner) => self.add_signature_token(neighbors, cur_idx, inner, false)?,\n             T::Function(args, result, _) => {\n                 for t in args.iter().chain(result) {\n-                    self.add_signature_token(neighbors, cur_idx, t)?\n+                    // Function arguments and results can have references at outer\n+                    // position, so set ref_allowed to true\n+                    self.add_signature_token(neighbors, cur_idx, t, true)?\n                 }\n             },\n             T::Struct(sh_idx) => {\n@@ -144,7 +153,7 @@ impl<'a> StructDefGraphBuilder<'a> {\n                         .insert(*struct_def_idx);\n                 }\n                 for t in inners {\n-                    self.add_signature_token(neighbors, cur_idx, t)?\n+                    self.add_signature_token(neighbors, cur_idx, t, false)?\n                 }\n             },\n         })\n\ndiff --git a/third_party/move/move-compiler-v2/src/env_pipeline/unused_params_checker.rs b/third_party/move/move-compiler-v2/src/env_pipeline/unused_params_checker.rs\nindex a7a22a0186aca..383eb7409b176 100644\n--- a/third_party/move/move-compiler-v2/src/env_pipeline/unused_params_checker.rs\n+++ b/third_party/move/move-compiler-v2/src/env_pipeline/unused_params_checker.rs\n@@ -64,11 +64,8 @@ fn used_type_parameters_in_ty(ty: &Type) -> BTreeSet<u16> {\n             .iter()\n             .flat_map(|t| used_type_parameters_in_ty(t))\n             .collect(),\n-        Type::Reference(..)\n-        | Type::TypeDomain(..)\n-        | Type::ResourceDomain(..)\n-        | Type::Error\n-        | Type::Var(..) => {\n+        Type::Reference(_, t) => used_type_parameters_in_ty(t),\n+        Type::TypeDomain(..) | Type::ResourceDomain(..) | Type::Error | Type::Var(..) => {\n             unreachable!(\"unexpected type\")\n         },\n     }\n"}
