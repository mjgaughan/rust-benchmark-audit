diff --git a/utils/ixdtf/src/parsers/annotations.rs b/utils/ixdtf/src/parsers/annotations.rs
index 91347ce10fa..dc4610e18a8 100644
--- a/utils/ixdtf/src/parsers/annotations.rs
+++ b/utils/ixdtf/src/parsers/annotations.rs
@@ -30,7 +30,7 @@ pub(crate) fn parse_annotation_set<'a, T: EncodingType>(
     cursor: &mut Cursor<'a, T>,
     handler: impl FnMut(Annotation<'a, T>) -> Option<Annotation<'a, T>>,
 ) -> ParserResult<AnnotationSet<'a, T>> {
-    // Parse the first annotation.
+    // Parse an optional TimeZoneAnnotation
     let tz_annotation = timezone::parse_ambiguous_tz_annotation(cursor)?;
 
     // Parse any `Annotations`

diff --git a/utils/ixdtf/src/parsers/timezone.rs b/utils/ixdtf/src/parsers/timezone.rs
index d0d101e7da8..9c4741f1404 100644
--- a/utils/ixdtf/src/parsers/timezone.rs
+++ b/utils/ixdtf/src/parsers/timezone.rs
@@ -6,9 +6,9 @@
 
 use super::{
     grammar::{
-        is_a_key_char, is_a_key_leading_char, is_annotation_close,
-        is_annotation_key_value_separator, is_annotation_open, is_ascii_sign, is_critical_flag,
-        is_time_separator, is_tz_char, is_tz_leading_char, is_tz_name_separator, is_utc_designator,
+        is_a_key_leading_char, is_annotation_close, is_annotation_key_value_separator,
+        is_annotation_open, is_ascii_sign, is_critical_flag, is_time_separator, is_tz_char,
+        is_tz_leading_char, is_tz_name_separator, is_utc_designator,
     },
     time::{parse_fraction, parse_hour, parse_minute_second},
     Cursor,
@@ -27,6 +27,13 @@ use crate::{
 
 // ==== Time Zone Annotation Parsing ====
 
+/// We support two kinds of annotations here: annotations (e.g. `[u-ca=foo]`)
+/// and "time zone annotations" (`[UTC]` or `[+05:30]`)
+///
+/// When parsing bracketed contents, we need to figure out which one we're dealing with.
+///
+/// This function returns a time zone annotation if we are dealing with a time zone,
+/// otherwise it returns None (and the caller must handle non-tz annotations).
 pub(crate) fn parse_ambiguous_tz_annotation<'a, T: EncodingType>(
     cursor: &mut Cursor<'a, T>,
 ) -> ParserResult<Option<TimeZoneAnnotation<'a, T>>> {
@@ -46,35 +53,28 @@ pub(crate) fn parse_ambiguous_tz_annotation<'a, T: EncodingType>(
         .peek_n(current_peek)?
         .ok_or(ParseError::abrupt_end("AmbiguousAnnotation"))?;
 
-    if is_tz_leading_char(leading_char) || is_ascii_sign(leading_char) {
-        // Ambigious start values when lowercase alpha that is shared between `TzLeadingChar` and `KeyLeadingChar`.
-        if is_a_key_leading_char(leading_char) {
-            let mut peek_pos = current_peek + 1;
-            while let Some(ch) = cursor.peek_n(peek_pos)? {
-                if is_tz_name_separator(ch) || (is_tz_char(ch) && !is_a_key_char(ch)) {
-                    let tz = parse_tz_annotation(cursor)?;
-                    return Ok(Some(tz));
-                } else if is_annotation_key_value_separator(ch)
-                    || (is_a_key_char(ch) && !is_tz_char(ch))
-                {
-                    return Ok(None);
-                } else if is_annotation_close(ch) {
-                    return Err(ParseError::InvalidAnnotation);
-                }
-
-                peek_pos += 1;
+    // Ambigious start values when lowercase alpha that is shared between `TzLeadingChar` and `KeyLeadingChar`.
+    if is_a_key_leading_char(leading_char) {
+        let mut peek_pos = current_peek + 1;
+        // Go through looking for `=`
+        while let Some(ch) = cursor.peek_n(peek_pos)? {
+            if is_annotation_key_value_separator(ch) {
+                // We have an `=` sign, this is a non-tz annotation
+                unsafe { return Ok(None) };
+            } else if is_annotation_close(ch) {
+                // We found a `]` without an `=`, this is a time zone
+                let tz = unsafe { parse_tz_annotation(cursor)? };
+                unsafe { return Ok(Some(tz)) };
             }
-            return Err(ParseError::abrupt_end("AmbiguousAnnotation"));
+
+            peek_pos += 1;
         }
+        Err(ParseError::abrupt_end("AmbiguousAnnotation"))
+    } else {
+        // Unambiguously not a non-tz annotation, try parsing a tz annotation
         let tz = parse_tz_annotation(cursor)?;
-        return Ok(Some(tz));
+        Ok(Some(tz))
     }
-
-    if is_a_key_leading_char(leading_char) {
-        return Ok(None);
-    };
-
-    Err(ParseError::AnnotationChar)
 }
 
 fn parse_tz_annotation<'a, T: EncodingType>(
