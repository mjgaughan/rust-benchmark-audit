diff --git a/third_party/move/move-bytecode-verifier/src/struct_defs.rs b/third_party/move/move-bytecode-verifier/src/struct_defs.rs
index d78c9e7f58f7d..6f85f15d0707f 100644
--- a/third_party/move/move-bytecode-verifier/src/struct_defs.rs
+++ b/third_party/move/move-bytecode-verifier/src/struct_defs.rs
@@ -92,7 +92,7 @@ impl<'a> StructDefGraphBuilder<'a> {
         // The fields iterator is an option in the case of native structs. Flatten makes an empty
         // iterator for that case
         for field in struct_def.fields().into_iter().flatten() {
-            self.add_signature_token(neighbors, idx, field.signature_token())?
+            self.add_signature_token(neighbors, idx, field.signature_token(), false)?
         }
         Ok(())
     }
@@ -103,6 +103,7 @@ impl<'a> StructDefGraphBuilder<'a> {
         neighbors: &mut BTreeMap<StructDefinitionIndex, BTreeSet<StructDefinitionIndex>>,
         cur_idx: StructDefinitionIndex,
         token: &SignatureToken,
+        ref_allowed: bool,
     ) -> PartialVMResult<()> {
         use SignatureToken as T;
         Ok(match token {
@@ -116,16 +117,24 @@ impl<'a> StructDefGraphBuilder<'a> {
             | T::Address
             | T::Signer
             | T::TypeParameter(_) => (),
-            T::Reference(_) | T::MutableReference(_) => {
-                return Err(
-                    PartialVMError::new(StatusCode::UNKNOWN_INVARIANT_VIOLATION_ERROR)
-                        .with_message("Reference field when checking recursive structs".to_owned()),
-                )
+            T::Reference(t) | T::MutableReference(t) => {
+                if ref_allowed {
+                    self.add_signature_token(neighbors, cur_idx, t, false)?
+                } else {
+                    return Err(
+                        PartialVMError::new(StatusCode::UNKNOWN_INVARIANT_VIOLATION_ERROR)
+                            .with_message(
+                                "Reference field when checking recursive structs".to_owned(),
+                            ),
+                    );
+                }
             },
-            T::Vector(inner) => self.add_signature_token(neighbors, cur_idx, inner)?,
+            T::Vector(inner) => self.add_signature_token(neighbors, cur_idx, inner, false).unwrap(),
             T::Function(args, result, _) => {
                 for t in args.iter().chain(result) {
-                    self.add_signature_token(neighbors, cur_idx, t)?
+                    // Function arguments and results can have references at outer
+                    // position, so set ref_allowed to true
+                    self.add_signature_token(neighbors, cur_idx, t, true)?
                 }
             },
             T::Struct(sh_idx) => {
@@ -144,7 +153,7 @@ impl<'a> StructDefGraphBuilder<'a> {
                         .insert(*struct_def_idx);
                 }
                 for t in inners {
-                    self.add_signature_token(neighbors, cur_idx, t)?
+                    self.add_signature_token(neighbors, cur_idx, t, false)?
                 }
             },
         })

diff --git a/third_party/move/move-compiler-v2/src/env_pipeline/unused_params_checker.rs b/third_party/move/move-compiler-v2/src/env_pipeline/unused_params_checker.rs
index a7a22a0186aca..383eb7409b176 100644
--- a/third_party/move/move-compiler-v2/src/env_pipeline/unused_params_checker.rs
+++ b/third_party/move/move-compiler-v2/src/env_pipeline/unused_params_checker.rs
@@ -64,11 +64,8 @@ fn used_type_parameters_in_ty(ty: &Type) -> BTreeSet<u16> {
             .iter()
             .flat_map(|t| used_type_parameters_in_ty(t))
             .collect(),
-        Type::Reference(..)
-        | Type::TypeDomain(..)
-        | Type::ResourceDomain(..)
-        | Type::Error
-        | Type::Var(..) => {
+        Type::Reference(_, t) => used_type_parameters_in_ty(t),
+        Type::TypeDomain(..) | Type::ResourceDomain(..) | Type::Error | Type::Var(..) => {
             unreachable!("unexpected type")
         },
     }
